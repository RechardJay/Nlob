---
title: "JDK内置httpClient缺陷-愚蠢的标准"
date: "2025-10-12"
tags: "技术,避坑"
---

写Nlob时，经常（99%的概率）在请求NotionAPI时爆出一个：

```plain text
Remote host terminated the handshake
javax.net.ssl.SSLHandshakeException: Remote host terminated the handshake
```

SSL（TLS）握手异常。这个错误的原因也很简单，客户端和服务器的配置参数不匹配。实际原因是复杂的，很多时候我们也无法控制服务器配置，加之网络波动。解决这个问题的方法一般是重试，等一会重试。

**但是**，如果用的是JDK内置的httpClient，出现这个问题就不奇怪了，换一个大牌的http库栓OKHttp、Apache HttpClient问题立马解决。

起初考虑到项目比较简单，一共俩请求不想引入外部库了，就直接用了JDK内置的httpClient，结果是10次请求9.9次异常。偶尔抽风可以成功一次。我也没在意，因为在GithubAction中的执行基本都是能成功的，加之Notion服务在国外，可能会对国内流量又限制，我本机一般不开模仿，网络异常啥的就忍了。

# 你看看人家？

转机是我意识到，用APIFox测试接口从来没异常过，NotionAPI文档中也提到无流量限制，1S三次请求可以保证个人用户的使用。并且我用CURL测试也从不会异常。起初以为是改改配置就行了吧，各种加JVM参数，自己写超时重试等等折腾半天。无果

最后才意识到也许是http端本身有问题呢？随即更换OKHttp，问题下一解决了。

# JDK httpClient之罪

作为编程语言内置工具包，JDK类库的实现是极其标准化的：

- 严格遵照RFC标准

- 缺少现实世界优化

- 对网络波动的容忍度更低

这种标准化，是一种学术理想版的设计，要么建立完美连接，要么异常。然而现实世界不是实验室，并没有如此理想的环境，JDK对服务器严格要求TLS配置，服务器也不惯着它，加之企业级防火墙、负载均衡后的特殊行为、CDN边缘节点差异、协议升级过程的不兼容等一系列不可控因素，JDK所要求的“完美连接”，几乎总是失效。

再看服务器那边， 云基础设施也许是复杂的(Cloudflare + 自有LB)，加之企业各种安全策略和不同的TLS特性共同早就了API的敏感。JDK的标准显得实在愚钝。

# 真正的生产工具

相比于学术标准，OKHttp等主流工具的设计哲学是“尽可能建立连接”：

协议不标准应答不规范？没事， OkHttp有更好的现实世界TLS支持，证书可以协商，对HTTP/2、代理等也支持；

网络抖动？ 连接预热、复用、缓存优化都加上、重置连接后自动恢复、路由失败时查找备用地址；

同时，作为一个独立且知名的专门处理http的项目，已经在生产环境中经历了无数迭代，相比于在实验和会议中做出来的JDK，什么时候用谁？一目了然。

总之一句话：外部环境不可控，强大的依赖库该用还得用。

# JDK还有哪些“坑”

包括但不限于

- **旧时间API**

- **Serializable**

- 默认编码

- 动态代理

- 泛型与擦除

每个都能单开一片文章痛骂

# 说点好话

这些所谓的坑，通常源于历史包袱、过度设计或现实世界适配不足，旧版绝对兼用和30年的历史实在沉重。但这不妨碍Java是一门伟大的编程语言，后端服务的半壁江山。同时避坑需注意：

- **明确优于隐式，不要依赖默认**

- **使用现代版、生产级新工具**

- **理解原理**